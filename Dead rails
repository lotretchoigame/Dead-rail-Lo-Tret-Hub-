local WindUI = loadstring(game:HttpGet("https://tree-hub.vercel.app/api/UI/WindUI"))()

function gradient(text, startColor, endColor)
    local result = ""
    local length = #text
    for i = 1, length do
        local t = (i - 1) / math.max(length - 1, 1)
        local r = math.floor((startColor.R + (endColor.R - startColor.R) * t) * 255)
        local g = math.floor((startColor.G + (endColor.G - startColor.G) * t) * 255)
        local b = math.floor((startColor.B + (endColor.B - startColor.B) * t) * 255)
        local char = text:sub(i, i)
        result = result .. "<font color=\"rgb(" .. r ..", " .. g .. ", " .. b .. ")\">" .. char .. "</font>"
    end
    return result
end

local Confirmed = false
WindUI:Popup({
    Title = "Welcome :D",
    Icon = "info",
    Content = "Do you want use this?  " .. gradient("Lo Tret", Color3.fromHex("#00FF87"), Color3.fromHex("#60EFFF")) .. " Script",
    Buttons = {
        { Title = "Cancel ;-;", Callback = function() end, Variant = "Tertiary" },
        { Title = "Continue :D", Icon = "arrow-right", Callback = function() Confirmed = true end, Variant = "Primary" }
    }
})
repeat task.wait() until Confirmed

local Window = WindUI:CreateWindow({
    Title = "Lo Tret-Dead Rails",
    Icon = "house",
    Author = "Dead Rails",
    Folder = "CloudHub",
    Size = UDim2.fromOffset(320, 200),
    Transparent = true,
    Theme = "Dark",
    UserEnabled = false,
    SideBarWidth = 200,
    HasOutline = true,
})

Window:EditOpenButton({
    Title = "Lo Tret-Dead Rails",
    Icon = "monitor",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    Draggable = true,
})

local Tabs = {
    Main = Window:Tab({ Title = "Main Tab", Icon = "house" }),
    Misc = Window:Tab({ Title = "Misc Tab", Icon = "mouse-pointer-2" }),
    Auto = Window:Tab({ Title = "Auto", Icon = "bolt" }),
    Esp = Window:Tab({ Title = "Esp", Icon = "eye", Desc = "Tracker" }),
    Visual = Window:Tab({ Title = "Visual", Icon = "layers-2" }),
    Player = Window:Tab({ Title = "Player", Icon = "dna" }),
    Teleport = Window:Tab({ Title = "Teleport", Icon = "sparkles" }),
    Show = Window:Tab({ Title = "Show", Icon = "tv-minimal" }),
    OP = Window:Tab({ Title = "OP", Icon = "sparkles" }),
    Theme = Window:Tab({ Title = "Theme", Icon = "bolt", Desc = "Set Theme" }),
    Setting = Window:Tab({ Title = "Setting", Icon = "setting", Desc = "Change Some" }),
    b = Window:Divider(),
    WindowTab = Window:Tab({ Title = "Made By @Lo_Tret_Meme ", Icon = "settings", Desc = "Only Youtube" }),
    be = Window:Divider(),
}

Window:SelectTab(1)
Tabs.Main:Paragraph({ Title = "Made By Lo Tret", Desc = "@Lo_Tret_Meme/Only Youtube", Image = "bird" })
Tabs.Misc:Button({ Title = "Click Me", Desc = "This is a simple button", Callback = function() print("Button Clicked!") end })

Tabs.Auto:Toggle({
    Title = "Auto Grab MoneyBag",
    Default = false,
    Callback = function(state)
        if state then
            task.spawn(function()
                local player = game.Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local hrp = character:WaitForChild("HumanoidRootPart")
                local RANGE = 25
                while state do
                    for _, prompt in ipairs(workspace:GetDescendants()) do
                        if prompt:IsA("ProximityPrompt") then
                            local part = prompt.Parent
                            if part and part:IsA("BasePart") then
                                local distance = (hrp.Position - part.Position).Magnitude
                                local name = part.Name:lower()
                                if distance <= RANGE and prompt.Enabled and (name:find("money") or name:find("cash") or name:find("bag")) then
                                    fireproximityprompt(prompt)
                                    task.wait(0.2)
                                end
                            end
                        end
                    end
                    task.wait(0.5)
                end
            end)
        end
    end
})

Tabs.Esp:Toggle({ Title = "Player Esp", Default = false, Callback = function(state)
                                                             local Settings = {
    TeamCheck = true, -- Overules Color
    Red = Color3.fromRGB(255, 0, 0),
    Green = Color3.fromRGB(0, 255, 0),
    Color = Color3.fromRGB(255, 0, 0),
    TeamColor = false
}

--// Locals
local player = game:GetService("Players").LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local mouse = player:GetMouse()

local function NewQuad(color)
    local quad = Drawing.new("Quad")
    quad.Visible = false
    quad.PointA = Vector2.new(0,0)
    quad.PointB = Vector2.new(0,0)
    quad.PointC = Vector2.new(0,0)
    quad.PointD = Vector2.new(0,0)
    quad.Color = color
    quad.Filled = true
    quad.Thickness = 1
    quad.Transparency = 0.25
    return quad
end

local function Colorize(color, lib)
    for i, v in pairs(lib) do
        v.Color = color
    end
end

local function ESP(object, plr)
    local part = object
    --// Quads for 3D box (6)
    local quads = {
        quad1 = NewQuad(Settings.Color),
        quad2 = NewQuad(Settings.Color),
        quad3 = NewQuad(Settings.Color),
        quad4 = NewQuad(Settings.Color),
        quad5 = NewQuad(Settings.Color),
        quad6 = NewQuad(Settings.Color)
    }

    --// Updates ESP in render loop
    local function Updater()
        local connection
        connection = game:GetService("RunService").RenderStepped:Connect(function()
            if plr.Character ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild(object.Name) ~= nil then
                    local partpos, onscreen = camera:WorldToViewportPoint(part.Position)
                    if onscreen then
                        local size_X = part.Size.X/2
                        local size_Y = part.Size.Y/2
                        local size_Z = part.Size.Z/2
                        
                        local Top1 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, size_Y, -size_Z)).p)
                        local Top2 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, size_Y, size_Z)).p)
                        local Top3 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, size_Y, size_Z)).p)
                        local Top4 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, size_Y, -size_Z)).p)
    
                        local Bottom1 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, -size_Y, -size_Z)).p)
                        local Bottom2 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(-size_X, -size_Y, size_Z)).p)
                        local Bottom3 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, -size_Y, size_Z)).p)
                        local Bottom4 = camera:WorldToViewportPoint((part.CFrame * CFrame.new(size_X, -size_Y, -size_Z)).p)
    
                        --// Top:
                        quads.quad1.PointA = Vector2.new(Top1.X, Top1.Y)
                        quads.quad1.PointB = Vector2.new(Top2.X, Top2.Y)
                        quads.quad1.PointC = Vector2.new(Top3.X, Top3.Y)
                        quads.quad1.PointD = Vector2.new(Top4.X, Top4.Y)
    
                        --//Bottom:
                        quads.quad2.PointA = Vector2.new(Bottom1.X, Bottom1.Y)
                        quads.quad2.PointB = Vector2.new(Bottom2.X, Bottom2.Y)
                        quads.quad2.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                        quads.quad2.PointD = Vector2.new(Bottom4.X, Bottom4.Y)
    
                        --//Sides:
                        quads.quad3.PointA = Vector2.new(Top1.X, Top1.Y)
                        quads.quad3.PointB = Vector2.new(Top2.X, Top2.Y)
                        quads.quad3.PointC = Vector2.new(Bottom2.X, Bottom2.Y)
                        quads.quad3.PointD = Vector2.new(Bottom1.X, Bottom1.Y)
                        
                        quads.quad4.PointA = Vector2.new(Top2.X, Top2.Y)
                        quads.quad4.PointB = Vector2.new(Top3.X, Top3.Y)
                        quads.quad4.PointC = Vector2.new(Bottom3.X, Bottom3.Y)
                        quads.quad4.PointD = Vector2.new(Bottom2.X, Bottom2.Y)
                        
                        quads.quad5.PointA = Vector2.new(Top3.X, Top3.Y)
                        quads.quad5.PointB = Vector2.new(Top4.X, Top4.Y)
                        quads.quad5.PointC = Vector2.new(Bottom4.X, Bottom4.Y)
                        quads.quad5.PointD = Vector2.new(Bottom3.X, Bottom3.Y)
    
                        quads.quad6.PointA = Vector2.new(Top4.X, Top4.Y)
                        quads.quad6.PointB = Vector2.new(Top1.X, Top1.Y)
                        quads.quad6.PointC = Vector2.new(Bottom1.X, Bottom1.Y)
                        quads.quad6.PointD = Vector2.new(Bottom4.X, Bottom4.Y)
    
                        if Settings.Team_Check then
                            if plr.TeamColor == player.TeamColor then
                                local group_color = Settings.Green
                                Colorize(group_color, quads)
                            else 
                                local group_color = Settings.Red
                                Colorize(group_color, quads)
                            end
                        else 
                            local group_color = Settings.Color
                            Colorize(group_color, quads)
                        end

                        if Settings.TeamColor then
                            Colorize(plr.TeamColor.Color, quads)
                        end
    
                        for u, x in pairs(quads) do
                            x.Visible = true
                        end
                    else 
                        for u, x in pairs(quads) do
                            x.Visible = false
                        end
                    end
            else 
                for u, x in pairs(quads) do
                    x.Visible = false
                end
                if game.Players:FindFirstChild(plr.Name) == nil then
                    connection:Disconnect()
                end
            end
        end)
    end
    coroutine.wrap(Updater)()
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
    spawn(function()
        if v.Name ~= player.Name then
            repeat wait() until v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild("Head") ~= nil
            for u, x in pairs(v.Character:GetChildren()) do
                if x:IsA("MeshPart") or x.Name == "Head" or x.Name == "Left Arm" or x.Name == "Right Arm" or x.Name == "Right Leg" or x.Name == "Left Leg" or x.Name == "Torso" then
                    coroutine.wrap(ESP)(x, v)
                end
            end
        end
    end)
end

game.Players.PlayerAdded:Connect(function(newplr)
    spawn(function()
        if newplr.Name ~= player.Name then
            repeat wait() until newplr.Character ~= nil and newplr.Character:FindFirstChild("Humanoid") ~= nil and newplr.Character:FindFirstChild("HumanoidRootPart") ~= nil and newplr.Character.Humanoid.Health > 0 and newplr.Character:FindFirstChild("Head") ~= nil
            for u, x in pairs(newplr.Character:GetChildren()) do
                if x:IsA("MeshPart") or x.Name == "Head" or x.Name == "Left Arm" or x.Name == "Right Arm" or x.Name == "Right Leg" or x.Name == "Left Leg" or x.Name == "Torso" then
                    coroutine.wrap(ESP)(x, newplr)
                end
            end
        end
    end)
end) end })

Tabs.Visual:Toggle({
    Title = "Full Bright",
    Default = false,
    Callback = function(state)
        if not _G.FullBrightExecuted then
            _G.FullBrightEnabled = false
            _G.NormalLightingSettings = {
                Brightness = game.Lighting.Brightness,
                ClockTime = game.Lighting.ClockTime,
                FogEnd = game.Lighting.FogEnd,
                GlobalShadows = game.Lighting.GlobalShadows,
                Ambient = game.Lighting.Ambient
            }
            local function enforceLighting()
                game.Lighting.Brightness = 1
                game.Lighting.ClockTime = 12
                game.Lighting.FogEnd = 786543
                game.Lighting.GlobalShadows = false
                game.Lighting.Ambient = Color3.fromRGB(178, 178, 178)
            end
            enforceLighting()
            game.Lighting:GetPropertyChangedSignal("Brightness"):Connect(function()
                if _G.FullBrightEnabled then game.Lighting.Brightness = 1 end
            end)
            game.Lighting:GetPropertyChangedSignal("ClockTime"):Connect(function()
                if _G.FullBrightEnabled then game.Lighting.ClockTime = 12 end
            end)
            game.Lighting:GetPropertyChangedSignal("FogEnd"):Connect(function()
                if _G.FullBrightEnabled then game.Lighting.FogEnd = 786543 end
            end)
            game.Lighting:GetPropertyChangedSignal("GlobalShadows"):Connect(function()
                if _G.FullBrightEnabled then game.Lighting.GlobalShadows = false end
            end)
            game.Lighting:GetPropertyChangedSignal("Ambient"):Connect(function()
                if _G.FullBrightEnabled then game.Lighting.Ambient = Color3.fromRGB(178, 178, 178) end
            end)
            _G.FullBrightExecuted = true
        end

        _G.FullBrightEnabled = state
        if not state then
            local normal = _G.NormalLightingSettings
            game.Lighting.Brightness = normal.Brightness
            game.Lighting.ClockTime = normal.ClockTime
            game.Lighting.FogEnd = normal.FogEnd
            game.Lighting.GlobalShadows = normal.GlobalShadows
            game.Lighting.Ambient = normal.Ambient
        end
    end
})

Tabs.Player:Toggle({
    Title = "Noclip",
    Default = false,
    Callback = function(state)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        if state then
            _G.NoclipConn = game:GetService("RunService").Stepped:Connect(function()
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end)
        else
            if _G.NoclipConn then
                _G.NoclipConn:Disconnect()
                _G.NoclipConn = nil
            end
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
})

Tabs.Teleport:Button({ Title = "Teleport To Train", Desc = "You Will On Train", Callback = function() print("Teleporting...") end })

Tabs.OP:Button({
    Title = "Get Horse Class",
    Desc = "Get Horse Class",
    Callback = function()
        local args = { "Horse" }
        local Remote = game:GetService("ReplicatedStorage").Shared.RemotePromise.Remotes
        Remote.C_BuyClass:FireServer(unpack(args))
        task.wait()
        Remote.C_EquipClass:FireServer(unpack(args))
    end
})

Tabs.Show:Toggle({ Title = "Show Time", Default = false, Callback = function(state) print(tostring(state)) end })

local themeValues = {}
for name, _ in pairs(WindUI:GetThemes()) do
    table.insert(themeValues, name)
end

local themeDropdown = Tabs.Theme:Dropdown({
    Title = "Select Theme",
    Multi = false,
    AllowNone = false,
    Value = nil,
    Values = themeValues,
    Callback = function(theme)
        WindUI:SetTheme(theme)
    end
})
themeDropdown:Select(WindUI:GetCurrentTheme())

local currentThemeName = WindUI:GetCurrentTheme()
local themes = WindUI:GetThemes()

local ThemeAccent = themes[currentThemeName].Accent
local ThemeOutline = themes[currentThemeName].Outline
local ThemeText = themes[currentThemeName].Text
local ThemePlaceholderText = themes[currentThemeName].PlaceholderText

function updateTheme()
    WindUI:AddTheme({
        Name = currentThemeName,
        Accent = ThemeAccent,
        Outline = ThemeOutline,
        Text = ThemeText,
        PlaceholderText = ThemePlaceholderText
    })
    WindUI:SetTheme(currentThemeName)
end

local CreateInput = Tabs.Theme:Input({
    Title = "Theme Name",
    Value = currentThemeName,
    Callback = function(name)
        currentThemeName = name
    end
})

Tabs.Theme:Colorpicker({
    Title = "Background Color",
    Default = Color3.fromHex(ThemeAccent),
    Callback = function(color)
        ThemeAccent = color:ToHex()
    end
})

Tabs.Theme:Colorpicker({
    Title = "Outline Color",
    Default = Color3.fromHex(ThemeOutline),
    Callback = function(color)
        ThemeOutline = color:ToHex()
    end
})

Tabs.Theme:Colorpicker({
    Title = "Text Color",
    Default = Color3.fromHex(ThemeText),
    Callback = function(color)
        ThemeText = color:ToHex()
    end
})

Tabs.Theme:Colorpicker({
    Title = "Placeholder Text Color",
    Default = Color3.fromHex(ThemePlaceholderText),
    Callback = function(color)
        ThemePlaceholderText = color:ToHex()
    end
})

Tabs.Theme:Button({
    Title = "Update Theme",
    Callback = function()
        updateTheme()
    end
})

local ToggleTransparency = Tabs.Setting:Toggle({
    Title = "Transparency",
    Callback = function(e)
        Window:ToggleTransparency(e)
    end,
    Value = WindUI:GetTransparency()
})
